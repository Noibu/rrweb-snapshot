{"version":3,"file":"rrweb-snapshot.min.js","sources":["../src/types.ts","../src/snapshot.ts","../src/css.ts","../src/rebuild.ts"],"sourcesContent":["export enum NodeType {\n  Document,\n  DocumentType,\n  Element,\n  Text,\n  CDATA,\n  Comment,\n}\n\nexport type documentNode = {\n  type: NodeType.Document;\n  childNodes: serializedNodeWithId[];\n};\n\nexport type documentTypeNode = {\n  type: NodeType.DocumentType;\n  name: string;\n  publicId: string;\n  systemId: string;\n};\n\nexport type attributes = {\n  [key: string]: string | boolean;\n};\nexport type elementNode = {\n  type: NodeType.Element;\n  tagName: string;\n  attributes: attributes;\n  childNodes: serializedNodeWithId[];\n  isSVG?: true;\n  needBlock?: boolean;\n};\n\nexport type textNode = {\n  type: NodeType.Text;\n  textContent: string;\n  isStyle?: true;\n};\n\nexport type cdataNode = {\n  type: NodeType.CDATA;\n  textContent: '';\n};\n\nexport type commentNode = {\n  type: NodeType.Comment;\n  textContent: string;\n};\n\nexport type serializedNode =\n  | documentNode\n  | documentTypeNode\n  | elementNode\n  | textNode\n  | cdataNode\n  | commentNode;\n\nexport type serializedNodeWithId = serializedNode & { id: number };\n\nexport type tagMap = {\n  [key: string]: string;\n};\n\nexport interface INode extends Node {\n  __sn: serializedNodeWithId;\n}\n\nexport type idNodeMap = {\n  [key: number]: INode;\n};\n","import {\n  serializedNode,\n  serializedNodeWithId,\n  NodeType,\n  attributes,\n  INode,\n  idNodeMap,\n} from './types';\n\nlet _id = 1;\n\nfunction genId(): number {\n  return _id++;\n}\n\nfunction getCssRulesString(s: CSSStyleSheet): string | null {\n  try {\n    const rules = s.rules || s.cssRules;\n    return rules\n      ? Array.from(rules).reduce(\n          (prev, cur) => prev + getCssRuleString(cur),\n          '',\n        )\n      : null;\n  } catch (error) {\n    return null;\n  }\n}\n\nfunction getCssRuleString(rule: CSSRule): string {\n  return isCSSImportRule(rule)\n    ? getCssRulesString(rule.styleSheet) || ''\n    : rule.cssText;\n}\n\nfunction isCSSImportRule(rule: CSSRule): rule is CSSImportRule {\n  return 'styleSheet' in rule;\n}\n\nfunction extractOrigin(url: string): string {\n  let origin;\n  if (url.indexOf('//') > -1) {\n    origin = url\n      .split('/')\n      .slice(0, 3)\n      .join('/');\n  } else {\n    origin = url.split('/')[0];\n  }\n  origin = origin.split('?')[0];\n  return origin;\n}\n\nconst URL_IN_CSS_REF = /url\\((?:'([^']*)'|\"([^\"]*)\"|([^)]*))\\)/gm;\nconst RELATIVE_PATH = /^(?!www\\.|(?:http|ftp)s?:\\/\\/|[A-Za-z]:\\\\|\\/\\/).*/;\nconst DATA_URI = /^(data:)([\\w\\/\\+\\-]+);(charset=[\\w-]+|base64).*,(.*)/i;\nexport function absoluteToStylesheet(cssText: string, href: string): string {\n  return cssText.replace(URL_IN_CSS_REF, (origin, path1, path2, path3) => {\n    const filePath = path1 || path2 || path3;\n    if (!filePath) {\n      return origin;\n    }\n    if (!RELATIVE_PATH.test(filePath)) {\n      return `url('${filePath}')`;\n    }\n    if (DATA_URI.test(filePath)) {\n      return `url(${filePath})`;\n    }\n    if (filePath[0] === '/') {\n      return `url('${extractOrigin(href) + filePath}')`;\n    }\n    const stack = href.split('/');\n    const parts = filePath.split('/');\n    stack.pop();\n    for (const part of parts) {\n      if (part === '.') {\n        continue;\n      } else if (part === '..') {\n        stack.pop();\n      } else {\n        stack.push(part);\n      }\n    }\n    return `url('${stack.join('/')}')`;\n  });\n}\n\nfunction getAbsoluteSrcsetString(doc: Document, attributeValue: string) {\n  if(attributeValue.trim() === \"\") {\n    return attributeValue\n  }\n\n  const srcsetValues = attributeValue.split(\",\")\n  // srcset attributes is defined as such:\n  // srcset = \"url size,url1 size1\"\n  const resultingSrcsetString = srcsetValues.map((srcItem) => {\n       // removing all but middle spaces\n       const trimmedSrcItem = srcItem.trimLeft().trimRight()\n       const urlAndSize = trimmedSrcItem.split(\" \")\n       // this means we have both 0:url and 1:size\n       if (urlAndSize.length === 2) {\n         const absUrl = absoluteToDoc(doc, urlAndSize[0])\n         return `${absUrl} ${urlAndSize[1]}`\n       } else if(urlAndSize.length === 1){\n         const absUrl = absoluteToDoc(doc, urlAndSize[0])\n         return `${absUrl}`\n       }\n       return \"\"\n  }).join(',')\n\n  return resultingSrcsetString\n}\n\nfunction absoluteToDoc(doc: Document, attributeValue: string): string {\n  if (attributeValue.trim() === \"\"){\n    return attributeValue\n  }\n  const a: HTMLAnchorElement = doc.createElement('a');\n  a.href = attributeValue;\n  return a.href;\n}\n\nfunction isSVGElement(el: Element): boolean {\n  return el.tagName === 'svg' || el instanceof SVGElement;\n}\n\nfunction serializeNode(\n  n: Node,\n  doc: Document,\n  blockClass: string | RegExp,\n  inlineStylesheet: boolean,\n  maskAllInputs: boolean,\n): serializedNode | false {\n  switch (n.nodeType) {\n    case n.DOCUMENT_NODE:\n      return {\n        type: NodeType.Document,\n        childNodes: [],\n      };\n    case n.DOCUMENT_TYPE_NODE:\n      return {\n        type: NodeType.DocumentType,\n        name: (n as DocumentType).name,\n        publicId: (n as DocumentType).publicId,\n        systemId: (n as DocumentType).systemId,\n      };\n    case n.ELEMENT_NODE:\n      let needBlock = false;\n      if (typeof blockClass === 'string') {\n        needBlock = (n as HTMLElement).classList.contains(blockClass);\n      } else {\n        (n as HTMLElement).classList.forEach(className => {\n          if (blockClass.test(className)) {\n            needBlock = true;\n          }\n        });\n      }\n      const tagName = (n as HTMLElement).tagName.toLowerCase();\n      let attributes: attributes = {};\n      for (const { name, value } of Array.from((n as HTMLElement).attributes)) {\n        // relative path in attribute\n        if (name === 'src' || name === 'href') {\n          attributes[name] = absoluteToDoc(doc, value);\n        } else if (name == 'srcset') {\n          attributes[name] = getAbsoluteSrcsetString(doc, value)\n        } else if (name === 'style') {\n          attributes[name] = absoluteToStylesheet(value, location.href);\n        } else {\n          attributes[name] = value;\n        }\n      }\n      // remote css\n      if (tagName === 'link' && inlineStylesheet) {\n        const stylesheet = Array.from(doc.styleSheets).find(s => {\n          return s.href === (n as HTMLLinkElement).href;\n        });\n        const cssText = getCssRulesString(stylesheet as CSSStyleSheet);\n        if (cssText) {\n          delete attributes.rel;\n          delete attributes.href;\n          attributes._cssText = absoluteToStylesheet(\n            cssText,\n            stylesheet!.href!,\n          );\n        }\n      }\n      // dynamic stylesheet\n      if (\n        tagName === 'style' &&\n        (n as HTMLStyleElement).sheet &&\n        // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element\n        !(\n          (n as HTMLElement).innerText ||\n          (n as HTMLElement).textContent ||\n          ''\n        ).trim().length\n      ) {\n        const cssText = getCssRulesString((n as HTMLStyleElement)\n          .sheet as CSSStyleSheet);\n        if (cssText) {\n          attributes._cssText = absoluteToStylesheet(cssText, location.href);\n        }\n      }\n      // form fields\n      if (\n        tagName === 'input' ||\n        tagName === 'textarea' ||\n        tagName === 'select'\n      ) {\n        const value = (n as HTMLInputElement | HTMLTextAreaElement).value;\n        if (\n          attributes.type !== 'radio' &&\n          attributes.type !== 'checkbox' &&\n          value\n        ) {\n          attributes.value = maskAllInputs ? '*'.repeat(value.length) : value;\n        } else if ((n as HTMLInputElement).checked) {\n          attributes.checked = (n as HTMLInputElement).checked;\n        }\n      }\n      if (tagName === 'option') {\n        const selectValue = (n as HTMLOptionElement).parentElement;\n        if (attributes.value === (selectValue as HTMLSelectElement).value) {\n          attributes.selected = (n as HTMLOptionElement).selected;\n        }\n      }\n      // canvas image data\n      if (tagName === 'canvas') {\n        attributes.rr_dataURL = (n as HTMLCanvasElement).toDataURL()\n      }\n      if (needBlock) {\n        const { width, height } = (n as HTMLElement).getBoundingClientRect();\n        attributes.rr_width = `${width}px`;\n        attributes.rr_height = `${height}px`;\n      }\n      return {\n        type: NodeType.Element,\n        tagName,\n        attributes,\n        childNodes: [],\n        isSVG: isSVGElement(n as Element) || undefined,\n        needBlock,\n      };\n    case n.TEXT_NODE:\n      // The parent node may not be a html element which has a tagName attribute.\n      // So just let it be undefined which is ok in this use case.\n      const parentTagName =\n        n.parentNode && (n.parentNode as HTMLElement).tagName;\n      let textContent = (n as Text).textContent;\n      const isStyle = parentTagName === 'STYLE' ? true : undefined;\n      if (isStyle && textContent) {\n        textContent = absoluteToStylesheet(textContent, location.href);\n      }\n      if (parentTagName === 'SCRIPT') {\n        textContent = 'SCRIPT_PLACEHOLDER';\n      }\n      return {\n        type: NodeType.Text,\n        textContent: textContent || '',\n        isStyle,\n      };\n    case n.CDATA_SECTION_NODE:\n      return {\n        type: NodeType.CDATA,\n        textContent: '',\n      };\n    case n.COMMENT_NODE:\n      return {\n        type: NodeType.Comment,\n        textContent: (n as Comment).textContent || '',\n      };\n    default:\n      return false;\n  }\n}\n\nexport function serializeNodeWithId(\n  n: Node | INode,\n  doc: Document,\n  map: idNodeMap,\n  blockClass: string | RegExp,\n  skipChild = false,\n  inlineStylesheet = true,\n  maskAllInputs = false,\n): serializedNodeWithId | null {\n  const _serializedNode = serializeNode(\n    n,\n    doc,\n    blockClass,\n    inlineStylesheet,\n    maskAllInputs,\n  );\n  if (!_serializedNode) {\n    // TODO: dev only\n    console.warn(n, 'not serialized');\n    return null;\n  }\n  let id;\n  // Try to reuse the previous id\n  if ('__sn' in n) {\n    id = n.__sn.id;\n  } else {\n    id = genId();\n  }\n  const serializedNode = Object.assign(_serializedNode, { id });\n  (n as INode).__sn = serializedNode;\n  map[id] = n as INode;\n  let recordChild = !skipChild;\n  if (serializedNode.type === NodeType.Element) {\n    recordChild = recordChild && !serializedNode.needBlock;\n    // this property was not needed in replay side\n    delete serializedNode.needBlock;\n  }\n  if (\n    (serializedNode.type === NodeType.Document ||\n      serializedNode.type === NodeType.Element) &&\n    recordChild\n  ) {\n    for (const childN of Array.from(n.childNodes)) {\n      const serializedChildNode = serializeNodeWithId(\n        childN,\n        doc,\n        map,\n        blockClass,\n        skipChild,\n        inlineStylesheet,\n        maskAllInputs,\n      );\n      if (serializedChildNode) {\n        serializedNode.childNodes.push(serializedChildNode);\n      }\n    }\n  }\n  return serializedNode;\n}\n\nfunction snapshot(\n  n: Document,\n  blockClass: string | RegExp = 'rr-block',\n  inlineStylesheet = true,\n  maskAllInputs = false,\n): [serializedNodeWithId | null, idNodeMap] {\n  const idNodeMap: idNodeMap = {};\n  return [\n    serializeNodeWithId(\n      n,\n      n,\n      idNodeMap,\n      blockClass,\n      false,\n      inlineStylesheet,\n      maskAllInputs,\n    ),\n    idNodeMap,\n  ];\n}\n\nexport default snapshot;\n","/**\n * This file is a fork of https://github.com/reworkcss/css/blob/master/lib/parse/index.js\n * I fork it because:\n * 1. The css library was built for node.js which does not have tree-shaking supports.\n * 2. Rewrites into typescript give us a better type interface.\n */\n\n/* tslint:disable no-conditional-assignment interface-name no-shadowed-variable */\n\nexport interface ParserOptions {\n  /** Silently fail on parse errors */\n  silent?: boolean;\n  /**\n   * The path to the file containing css.\n   * Makes errors and source maps more helpful, by letting them know where code comes from.\n   */\n  source?: string;\n}\n\n/**\n * Error thrown during parsing.\n */\nexport interface ParserError {\n  /** The full error message with the source position. */\n  message?: string;\n  /** The error message without position. */\n  reason?: string;\n  /** The value of options.source if passed to css.parse. Otherwise undefined. */\n  filename?: string;\n  line?: number;\n  column?: number;\n  /** The portion of code that couldn't be parsed. */\n  source?: string;\n}\n\nexport interface Loc {\n  line?: number;\n  column?: number;\n}\n\n/**\n * Base AST Tree Node.\n */\nexport interface Node {\n  /** The possible values are the ones listed in the Types section on https://github.com/reworkcss/css page. */\n  type?: string;\n  /** A reference to the parent node, or null if the node has no parent. */\n  parent?: Node;\n  /** Information about the position in the source string that corresponds to the node. */\n  position?: {\n    start?: Loc;\n    end?: Loc;\n    /** The value of options.source if passed to css.parse. Otherwise undefined. */\n    source?: string;\n    /** The full source string passed to css.parse. */\n    content?: string;\n  };\n}\n\nexport interface Rule extends Node {\n  /** The list of selectors of the rule, split on commas. Each selector is trimmed from whitespace and comments. */\n  selectors?: string[];\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\nexport interface Declaration extends Node {\n  /** The property name, trimmed from whitespace and comments. May not be empty. */\n  property?: string;\n  /** The value of the property, trimmed from whitespace and comments. Empty values are allowed. */\n  value?: string;\n}\n\n/**\n * A rule-level or declaration-level comment. Comments inside selectors, properties and values etc. are lost.\n */\nexport interface Comment extends Node {\n  comment?: string;\n}\n\n/**\n * The @charset at-rule.\n */\nexport interface Charset extends Node {\n  /** The part following @charset. */\n  charset?: string;\n}\n\n/**\n * The @custom-media at-rule\n */\nexport interface CustomMedia extends Node {\n  /** The ---prefixed name. */\n  name?: string;\n  /** The part following the name. */\n  media?: string;\n}\n\n/**\n * The @document at-rule.\n */\nexport interface Document extends Node {\n  /** The part following @document. */\n  document?: string;\n  /** The vendor prefix in @document, or undefined if there is none. */\n  vendor?: string;\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules?: Array<Rule | Comment | AtRule>;\n}\n\n/**\n * The @font-face at-rule.\n */\nexport interface FontFace extends Node {\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\n/**\n * The @host at-rule.\n */\nexport interface Host extends Node {\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules?: Array<Rule | Comment | AtRule>;\n}\n\n/**\n * The @import at-rule.\n */\nexport interface Import extends Node {\n  /** The part following @import. */\n  import?: string;\n}\n\n/**\n * The @keyframes at-rule.\n */\nexport interface KeyFrames extends Node {\n  /** The name of the keyframes rule. */\n  name?: string;\n  /** The vendor prefix in @keyframes, or undefined if there is none. */\n  vendor?: string;\n  /** Array of nodes with the types keyframe and comment. */\n  keyframes?: Array<KeyFrame | Comment>;\n}\n\nexport interface KeyFrame extends Node {\n  /** The list of \"selectors\" of the keyframe rule, split on commas. Each “selector” is trimmed from whitespace. */\n  values?: string[];\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\n/**\n * The @media at-rule.\n */\nexport interface Media extends Node {\n  /** The part following @media. */\n  media?: string;\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules?: Array<Rule | Comment | AtRule>;\n}\n\n/**\n * The @namespace at-rule.\n */\nexport interface Namespace extends Node {\n  /** The part following @namespace. */\n  namespace?: string;\n}\n\n/**\n * The @page at-rule.\n */\nexport interface Page extends Node {\n  /** The list of selectors of the rule, split on commas. Each selector is trimmed from whitespace and comments. */\n  selectors?: string[];\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\n/**\n * The @supports at-rule.\n */\nexport interface Supports extends Node {\n  /** The part following @supports. */\n  supports?: string;\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules?: Array<Rule | Comment | AtRule>;\n}\n\n/** All at-rules. */\nexport type AtRule =\n  | Charset\n  | CustomMedia\n  | Document\n  | FontFace\n  | Host\n  | Import\n  | KeyFrames\n  | Media\n  | Namespace\n  | Page\n  | Supports;\n\n/**\n * A collection of rules\n */\nexport interface StyleRules {\n  source?: string;\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules: Array<Rule | Comment | AtRule>;\n  /** Array of Errors. Errors collected during parsing when option silent is true. */\n  parsingErrors?: ParserError[];\n}\n\n/**\n * The root node returned by css.parse.\n */\nexport interface Stylesheet extends Node {\n  stylesheet?: StyleRules;\n}\n\n// http://www.w3.org/TR/CSS21/grammar.html\n// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027\nconst commentre = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\n\nexport function parse(css: string, options: ParserOptions = {}) {\n  /**\n   * Positional.\n   */\n\n  let lineno = 1;\n  let column = 1;\n\n  /**\n   * Update lineno and column based on `str`.\n   */\n\n  function updatePosition(str: string) {\n    const lines = str.match(/\\n/g);\n    if (lines) {\n      lineno += lines.length;\n    }\n    let i = str.lastIndexOf('\\n');\n    column = i === -1 ? column + str.length : str.length - i;\n  }\n\n  /**\n   * Mark position and patch `node.position`.\n   */\n\n  function position() {\n    const start = { line: lineno, column };\n    return (\n      node: Rule | Declaration | Comment | AtRule | Stylesheet | KeyFrame,\n    ) => {\n      node.position = new Position(start);\n      whitespace();\n      return node;\n    };\n  }\n\n  /**\n   * Store position information for a node\n   */\n\n  class Position {\n    public content!: string;\n    public start!: Loc;\n    public end!: Loc;\n    public source?: string;\n\n    constructor(start: Loc) {\n      this.start = start;\n      this.end = { line: lineno, column };\n      this.source = options.source;\n    }\n  }\n\n  /**\n   * Non-enumerable source string\n   */\n\n  Position.prototype.content = css;\n\n  const errorsList: ParserError[] = [];\n\n  function error(msg: string) {\n    const err = new Error(\n      options.source + ':' + lineno + ':' + column + ': ' + msg,\n    ) as ParserError;\n    err.reason = msg;\n    err.filename = options.source;\n    err.line = lineno;\n    err.column = column;\n    err.source = css;\n\n    if (options.silent) {\n      errorsList.push(err);\n    } else {\n      throw err;\n    }\n  }\n\n  /**\n   * Parse stylesheet.\n   */\n\n  function stylesheet(): Stylesheet {\n    const rulesList = rules();\n\n    return {\n      type: 'stylesheet',\n      stylesheet: {\n        source: options.source,\n        rules: rulesList,\n        parsingErrors: errorsList,\n      },\n    };\n  }\n\n  /**\n   * Opening brace.\n   */\n\n  function open() {\n    return match(/^{\\s*/);\n  }\n\n  /**\n   * Closing brace.\n   */\n\n  function close() {\n    return match(/^}/);\n  }\n\n  /**\n   * Parse ruleset.\n   */\n\n  function rules() {\n    let node: Rule | void;\n    const rules: Rule[] = [];\n    whitespace();\n    comments(rules);\n    while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {\n      if (node !== false) {\n        rules.push(node);\n        comments(rules);\n      }\n    }\n    return rules;\n  }\n\n  /**\n   * Match `re` and return captures.\n   */\n\n  function match(re: RegExp) {\n    const m = re.exec(css);\n    if (!m) {\n      return;\n    }\n    const str = m[0];\n    updatePosition(str);\n    css = css.slice(str.length);\n    return m;\n  }\n\n  /**\n   * Parse whitespace.\n   */\n\n  function whitespace() {\n    match(/^\\s*/);\n  }\n\n  /**\n   * Parse comments;\n   */\n\n  function comments(rules: Rule[] = []) {\n    let c: Comment | void;\n    while ((c = comment())) {\n      if (c !== false) {\n        rules.push(c);\n      }\n      c = comment();\n    }\n    return rules;\n  }\n\n  /**\n   * Parse comment.\n   */\n\n  function comment() {\n    const pos = position();\n    if ('/' !== css.charAt(0) || '*' !== css.charAt(1)) {\n      return;\n    }\n\n    let i = 2;\n    while (\n      '' !== css.charAt(i) &&\n      ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1))\n    ) {\n      ++i;\n    }\n    i += 2;\n\n    if ('' === css.charAt(i - 1)) {\n      return error('End of comment missing');\n    }\n\n    const str = css.slice(2, i - 2);\n    column += 2;\n    updatePosition(str);\n    css = css.slice(i);\n    column += 2;\n\n    return pos({\n      type: 'comment',\n      comment: str,\n    });\n  }\n\n  /**\n   * Parse selector.\n   */\n\n  function selector() {\n    const m = match(/^([^{]+)/);\n    if (!m) {\n      return;\n    }\n    /* @fix Remove all comments from selectors\n     * http://ostermiller.org/findcomment.html */\n    return trim(m[0])\n      .replace(/\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*\\/+/g, '')\n      .replace(/\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'/g, m => {\n        return m.replace(/,/g, '\\u200C');\n      })\n      .split(/\\s*(?![^(]*\\)),\\s*/)\n      .map(s => {\n        return s.replace(/\\u200C/g, ',');\n      });\n  }\n\n  /**\n   * Parse declaration.\n   */\n\n  function declaration(): Declaration | void | never {\n    const pos = position();\n\n    // prop\n    let propMatch = match(/^(\\*?[-#\\/\\*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/);\n    if (!propMatch) {\n      return;\n    }\n    const prop = trim(propMatch[0]);\n\n    // :\n    if (!match(/^:\\s*/)) {\n      return error(`property missing ':'`);\n    }\n\n    // val\n    const val = match(/^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+)/);\n\n    const ret = pos({\n      type: 'declaration',\n      property: prop.replace(commentre, ''),\n      value: val ? trim(val[0]).replace(commentre, '') : '',\n    });\n\n    // ;\n    match(/^[;\\s]*/);\n\n    return ret;\n  }\n\n  /**\n   * Parse declarations.\n   */\n\n  function declarations() {\n    const decls: Array<object> = [];\n\n    if (!open()) {\n      return error(`missing '{'`);\n    }\n    comments(decls);\n\n    // declarations\n    let decl;\n    while ((decl = declaration())) {\n      if ((decl as unknown) !== false) {\n        decls.push(decl);\n        comments(decls);\n      }\n      decl = declaration();\n    }\n\n    if (!close()) {\n      return error(`missing '}'`);\n    }\n    return decls;\n  }\n\n  /**\n   * Parse keyframe.\n   */\n\n  function keyframe() {\n    let m;\n    const vals = [];\n    const pos = position();\n\n    while ((m = match(/^((\\d+\\.\\d+|\\.\\d+|\\d+)%?|[a-z]+)\\s*/))) {\n      vals.push(m[1]);\n      match(/^,\\s*/);\n    }\n\n    if (!vals.length) {\n      return;\n    }\n\n    return pos({\n      type: 'keyframe',\n      values: vals,\n      declarations: declarations() as Declaration[],\n    });\n  }\n\n  /**\n   * Parse keyframes.\n   */\n\n  function atkeyframes() {\n    const pos = position();\n    let m = match(/^@([-\\w]+)?keyframes\\s*/);\n\n    if (!m) {\n      return;\n    }\n    const vendor = m[1];\n\n    // identifier\n    m = match(/^([-\\w]+)\\s*/);\n    if (!m) {\n      return error('@keyframes missing name');\n    }\n    const name = m[1];\n\n    if (!open()) {\n      return error(`@keyframes missing '{'`);\n    }\n\n    let frame;\n    let frames = comments();\n    while ((frame = keyframe())) {\n      frames.push(frame);\n      frames = frames.concat(comments());\n    }\n\n    if (!close()) {\n      return error(`@keyframes missing '}'`);\n    }\n\n    return pos({\n      type: 'keyframes',\n      name,\n      vendor,\n      keyframes: frames,\n    });\n  }\n\n  /**\n   * Parse supports.\n   */\n\n  function atsupports() {\n    const pos = position();\n    const m = match(/^@supports *([^{]+)/);\n\n    if (!m) {\n      return;\n    }\n    const supports = trim(m[1]);\n\n    if (!open()) {\n      return error(`@supports missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@supports missing '}'`);\n    }\n\n    return pos({\n      type: 'supports',\n      supports,\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse host.\n   */\n\n  function athost() {\n    const pos = position();\n    const m = match(/^@host\\s*/);\n\n    if (!m) {\n      return;\n    }\n\n    if (!open()) {\n      return error(`@host missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@host missing '}'`);\n    }\n\n    return pos({\n      type: 'host',\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse media.\n   */\n\n  function atmedia() {\n    const pos = position();\n    const m = match(/^@media *([^{]+)/);\n\n    if (!m) {\n      return;\n    }\n    const media = trim(m[1]);\n\n    if (!open()) {\n      return error(`@media missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@media missing '}'`);\n    }\n\n    return pos({\n      type: 'media',\n      media,\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse custom-media.\n   */\n\n  function atcustommedia() {\n    const pos = position();\n    const m = match(/^@custom-media\\s+(--[^\\s]+)\\s*([^{;]+);/);\n    if (!m) {\n      return;\n    }\n\n    return pos({\n      type: 'custom-media',\n      name: trim(m[1]),\n      media: trim(m[2]),\n    });\n  }\n\n  /**\n   * Parse paged media.\n   */\n\n  function atpage() {\n    const pos = position();\n    const m = match(/^@page */);\n    if (!m) {\n      return;\n    }\n\n    const sel = selector() || [];\n\n    if (!open()) {\n      return error(`@page missing '{'`);\n    }\n    let decls = comments();\n\n    // declarations\n    let decl;\n    while ((decl = declaration())) {\n      decls.push(decl);\n      decls = decls.concat(comments());\n    }\n\n    if (!close()) {\n      return error(`@page missing '}'`);\n    }\n\n    return pos({\n      type: 'page',\n      selectors: sel,\n      declarations: decls,\n    });\n  }\n\n  /**\n   * Parse document.\n   */\n\n  function atdocument() {\n    const pos = position();\n    const m = match(/^@([-\\w]+)?document *([^{]+)/);\n    if (!m) {\n      return;\n    }\n\n    const vendor = trim(m[1]);\n    const doc = trim(m[2]);\n\n    if (!open()) {\n      return error(`@document missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@document missing '}'`);\n    }\n\n    return pos({\n      type: 'document',\n      document: doc,\n      vendor,\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse font-face.\n   */\n\n  function atfontface() {\n    const pos = position();\n    const m = match(/^@font-face\\s*/);\n    if (!m) {\n      return;\n    }\n\n    if (!open()) {\n      return error(`@font-face missing '{'`);\n    }\n    let decls = comments();\n\n    // declarations\n    let decl;\n    while ((decl = declaration())) {\n      decls.push(decl);\n      decls = decls.concat(comments());\n    }\n\n    if (!close()) {\n      return error(`@font-face missing '}'`);\n    }\n\n    return pos({\n      type: 'font-face',\n      declarations: decls,\n    });\n  }\n\n  /**\n   * Parse import\n   */\n\n  const atimport = _compileAtrule('import');\n\n  /**\n   * Parse charset\n   */\n\n  const atcharset = _compileAtrule('charset');\n\n  /**\n   * Parse namespace\n   */\n\n  const atnamespace = _compileAtrule('namespace');\n\n  /**\n   * Parse non-block at-rules\n   */\n\n  function _compileAtrule(name: string) {\n    const re = new RegExp('^@' + name + '\\\\s*([^;]+);');\n    return () => {\n      const pos = position();\n      const m = match(re);\n      if (!m) {\n        return;\n      }\n      const ret: Record<string, string> = { type: name };\n      ret[name] = m[1].trim();\n      return pos(ret);\n    };\n  }\n\n  /**\n   * Parse at rule.\n   */\n\n  function atrule() {\n    if (css[0] !== '@') {\n      return;\n    }\n\n    return (\n      atkeyframes() ||\n      atmedia() ||\n      atcustommedia() ||\n      atsupports() ||\n      atimport() ||\n      atcharset() ||\n      atnamespace() ||\n      atdocument() ||\n      atpage() ||\n      athost() ||\n      atfontface()\n    );\n  }\n\n  /**\n   * Parse rule.\n   */\n\n  function rule() {\n    const pos = position();\n    const sel = selector();\n\n    if (!sel) {\n      return error('selector missing');\n    }\n    comments();\n\n    return pos({\n      type: 'rule',\n      selectors: sel,\n      declarations: declarations() as Declaration[],\n    });\n  }\n\n  return addParent(stylesheet());\n}\n\n/**\n * Trim `str`.\n */\n\nfunction trim(str: string) {\n  return str ? str.replace(/^\\s+|\\s+$/g, '') : '';\n}\n\n/**\n * Adds non-enumerable parent node reference to each node.\n */\n\nfunction addParent(obj: Stylesheet, parent?: Stylesheet) {\n  const isNode = obj && typeof obj.type === 'string';\n  const childParent = isNode ? obj : parent;\n\n  for (const k of Object.keys(obj)) {\n    const value = obj[k as keyof Stylesheet];\n    if (Array.isArray(value)) {\n      value.forEach(v => {\n        addParent(v, childParent);\n      });\n    } else if (value && typeof value === 'object') {\n      addParent((value as unknown) as Stylesheet, childParent);\n    }\n  }\n\n  if (isNode) {\n    Object.defineProperty(obj, 'parent', {\n      configurable: true,\n      writable: true,\n      enumerable: false,\n      value: parent || null,\n    });\n  }\n\n  return obj;\n}\n","import { parse } from './css';\nimport {\n  serializedNodeWithId,\n  NodeType,\n  tagMap,\n  elementNode,\n  idNodeMap,\n  INode,\n} from './types';\n\nconst tagMap: tagMap = {\n  script: 'noscript',\n  // camel case svg element tag names\n  altglyph: 'altGlyph',\n  altglyphdef: 'altGlyphDef',\n  altglyphitem: 'altGlyphItem',\n  animatecolor: 'animateColor',\n  animatemotion: 'animateMotion',\n  animatetransform: 'animateTransform',\n  clippath: 'clipPath',\n  feblend: 'feBlend',\n  fecolormatrix: 'feColorMatrix',\n  fecomponenttransfer: 'feComponentTransfer',\n  fecomposite: 'feComposite',\n  feconvolvematrix: 'feConvolveMatrix',\n  fediffuselighting: 'feDiffuseLighting',\n  fedisplacementmap: 'feDisplacementMap',\n  fedistantlight: 'feDistantLight',\n  fedropshadow: 'feDropShadow',\n  feflood: 'feFlood',\n  fefunca: 'feFuncA',\n  fefuncb: 'feFuncB',\n  fefuncg: 'feFuncG',\n  fefuncr: 'feFuncR',\n  fegaussianblur: 'feGaussianBlur',\n  feimage: 'feImage',\n  femerge: 'feMerge',\n  femergenode: 'feMergeNode',\n  femorphology: 'feMorphology',\n  feoffset: 'feOffset',\n  fepointlight: 'fePointLight',\n  fespecularlighting: 'feSpecularLighting',\n  fespotlight: 'feSpotLight',\n  fetile: 'feTile',\n  feturbulence: 'feTurbulence',\n  foreignobject: 'foreignObject',\n  glyphref: 'glyphRef',\n  lineargradient: 'linearGradient',\n  radialgradient: 'radialGradient',\n};\nfunction getTagName(n: elementNode): string {\n  let tagName = tagMap[n.tagName] ? tagMap[n.tagName] : n.tagName;\n  if (tagName === 'link' && n.attributes._cssText) {\n    tagName = 'style';\n  }\n  return tagName;\n}\n\nconst HOVER_SELECTOR = /([^\\\\]):hover/g;\nexport function addHoverClass(cssText: string): string {\n  const ast = parse(cssText, { silent: true });\n  if (!ast.stylesheet) {\n    return cssText;\n  }\n  ast.stylesheet.rules.forEach(rule => {\n    if ('selectors' in rule) {\n      (rule.selectors || []).forEach((selector: string) => {\n        if (HOVER_SELECTOR.test(selector)) {\n          const newSelector = selector.replace(HOVER_SELECTOR, '$1.\\\\:hover');\n          cssText = cssText.replace(selector, `${selector}, ${newSelector}`);\n        }\n      });\n    }\n  });\n  return cssText;\n}\n\nfunction buildNode(\n  n: serializedNodeWithId,\n  doc: Document,\n  HACK_CSS: boolean,\n): Node | null {\n  switch (n.type) {\n    case NodeType.Document:\n      return doc.implementation.createDocument(null, '', null);\n    case NodeType.DocumentType:\n      return doc.implementation.createDocumentType(\n        n.name,\n        n.publicId,\n        n.systemId,\n      );\n    case NodeType.Element:\n      const tagName = getTagName(n);\n      let node: Element;\n      if (n.isSVG) {\n        node = doc.createElementNS('http://www.w3.org/2000/svg', tagName);\n      } else {\n        node = doc.createElement(tagName);\n      }\n      for (const name in n.attributes) {\n        if (!n.attributes.hasOwnProperty(name)) {\n          continue\n        }\n        let value = n.attributes[name];\n        value = typeof value === 'boolean' ? '' : value;\n        // attribute names start with rr_ are internal attributes added by rrweb\n        if (!name.startsWith('rr_')) {\n          const isTextarea = tagName === 'textarea' && name === 'value';\n          const isRemoteOrDynamicCss =\n            tagName === 'style' && name === '_cssText';\n          if (isRemoteOrDynamicCss && HACK_CSS) {\n            value = addHoverClass(value);\n          }\n          if (isTextarea || isRemoteOrDynamicCss) {\n            const child = doc.createTextNode(value);\n            // https://github.com/rrweb-io/rrweb/issues/112\n            for (const c of Array.from(node.childNodes)) {\n              if (c.nodeType === node.TEXT_NODE) {\n                node.removeChild(c);\n              }\n            }\n            node.appendChild(child);\n            continue;\n          }\n          if (tagName === 'iframe' && name === 'src') {\n            continue;\n          }\n          try {\n            if (n.isSVG && name === 'xlink:href') {\n              node.setAttributeNS('http://www.w3.org/1999/xlink', name, value);\n            } else {\n              node.setAttribute(name, value);\n            }\n          } catch (error) {\n            // skip invalid attribute\n          }\n        } else {\n          // handle internal attributes\n          if (tagName === 'canvas' && name === 'rr_dataURL') {\n            const image = document.createElement('img')\n            image.src = value\n            image.onload = () => {\n              const ctx = (node as HTMLCanvasElement).getContext('2d')\n              if (ctx) {\n                ctx.drawImage(image, 0, 0, image.width, image.height)\n              }\n            }\n          }\n          if (name === 'rr_width') {\n            (node as HTMLElement).style.width = value;\n          }\n          if (name === 'rr_height') {\n            (node as HTMLElement).style.height = value;\n          }\n        }\n      }\n      return node;\n    case NodeType.Text:\n      return doc.createTextNode(\n        n.isStyle && HACK_CSS ? addHoverClass(n.textContent) : n.textContent,\n      );\n    case NodeType.CDATA:\n      return doc.createCDATASection(n.textContent);\n    case NodeType.Comment:\n      return doc.createComment(n.textContent);\n    default:\n      return null;\n  }\n}\n\nexport function buildNodeWithSN(\n  n: serializedNodeWithId,\n  doc: Document,\n  map: idNodeMap,\n  skipChild = false,\n  HACK_CSS = true,\n): INode | null {\n  let node = buildNode(n, doc, HACK_CSS);\n  if (!node) {\n    return null;\n  }\n  // use target document as root document\n  if (n.type === NodeType.Document) {\n    // close before open to make sure document was closed\n    doc.close();\n    doc.open();\n    node = doc;\n  }\n\n  (node as INode).__sn = n;\n  map[n.id] = node as INode;\n  if (\n    (n.type === NodeType.Document || n.type === NodeType.Element) &&\n    !skipChild\n  ) {\n    for (const childN of n.childNodes) {\n      const childNode = buildNodeWithSN(childN, doc, map, false, HACK_CSS);\n      if (!childNode) {\n        console.warn('Failed to rebuild', childN);\n      } else {\n        node.appendChild(childNode);\n      }\n    }\n  }\n  return node as INode;\n}\n\nfunction rebuild(\n  n: serializedNodeWithId,\n  doc: Document,\n  /**\n   * This is not a public API yet, just for POC\n   */\n  HACK_CSS: boolean = true,\n): [Node | null, idNodeMap] {\n  const idNodeMap: idNodeMap = {};\n  return [buildNodeWithSN(n, doc, idNodeMap, false, HACK_CSS), idNodeMap];\n}\n\nexport default rebuild;\n"],"names":["NodeType","_id","genId","getCssRulesString","s","rules","cssRules","Array","from","reduce","prev","cur","getCssRuleString","error","rule","isCSSImportRule","styleSheet","cssText","extractOrigin","url","indexOf","split","slice","join","URL_IN_CSS_REF","RELATIVE_PATH","DATA_URI","absoluteToStylesheet","href","replace","origin","path1","path2","path3","filePath","test","stack","parts","pop","parts_1","_i","part","push","getAbsoluteSrcsetString","doc","attributeValue","trim","map","srcItem","urlAndSize","trimLeft","trimRight","length","absoluteToDoc","a","createElement","isSVGElement","el","tagName","SVGElement","serializeNode","n","blockClass","inlineStylesheet","maskAllInputs","nodeType","DOCUMENT_NODE","type","Document","childNodes","DOCUMENT_TYPE_NODE","DocumentType","name","publicId","systemId","ELEMENT_NODE","needBlock_1","classList","contains","forEach","className","toLowerCase","attributes_1","_a","attributes","_b","value","location","stylesheet","styleSheets","find","rel","_cssText","sheet","innerText","textContent","repeat","checked","selectValue","parentElement","selected","rr_dataURL","toDataURL","_c","width","height","rr_width","rr_height","Element","isSVG","undefined","needBlock","TEXT_NODE","parentTagName","parentNode","isStyle","Text","CDATA_SECTION_NODE","CDATA","COMMENT_NODE","Comment","serializeNodeWithId","skipChild","id","_serializedNode","console","warn","__sn","serializedNode","Object","assign","recordChild","serializedChildNode","snapshot","idNodeMap","commentre","parse","css","options","lineno","column","updatePosition","str","lines","match","i","lastIndexOf","position","start","line","node","Position","whitespace","this","end","source","prototype","content","errorsList","msg","err","Error","reason","filename","silent","open","close","comments","charAt","atrule","re","m","exec","c","comment","pos","selector","declaration","propMatch","prop","val","ret","property","declarations","decl","decls","keyframe","vals","values","rulesList","atimport","_compileAtrule","atcharset","atnamespace","RegExp","vendor","frame","frames","concat","keyframes","atkeyframes","media","style","atmedia","atcustommedia","supports","atsupports","document","atdocument","sel","selectors","atpage","athost","atfontface","addParent","parsingErrors","obj","parent","isNode","childParent","keys","isArray","v","defineProperty","configurable","writable","enumerable","tagMap","script","altglyph","altglyphdef","altglyphitem","animatecolor","animatemotion","animatetransform","clippath","feblend","fecolormatrix","fecomponenttransfer","fecomposite","feconvolvematrix","fediffuselighting","fedisplacementmap","fedistantlight","fedropshadow","feflood","fefunca","fefuncb","fefuncg","fefuncr","fegaussianblur","feimage","femerge","femergenode","femorphology","feoffset","fepointlight","fespecularlighting","fespotlight","fetile","feturbulence","foreignobject","glyphref","lineargradient","radialgradient","getTagName","HOVER_SELECTOR","addHoverClass","ast","newSelector","buildNode","HACK_CSS","implementation","createDocument","createDocumentType","node_1","createElementNS","hasOwnProperty","startsWith","image_1","src","onload","ctx","getContext","drawImage","isTextarea","isRemoteOrDynamicCss","child","createTextNode","removeChild","appendChild","setAttributeNS","setAttribute","createCDATASection","createComment","buildNodeWithSN","childN","childNode","rebuild"],"mappings":"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"}